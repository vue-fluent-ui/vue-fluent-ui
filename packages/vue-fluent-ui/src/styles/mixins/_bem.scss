/**
 * @fileOverview BEM 相关的 mixins
 */
@use 'config';
@use "sass:selector";

/**
 * B - Block
 * 创建一个 BEM 块选择器。
 *
 * @param {string} $block - 块的名称

 */
@mixin b($block) {
  $namespace: #{config.$namespace}-#{$block};
  .#{$namespace} {
    @content;
  }
}

/**
 * E - Element
 * 创建一个 BEM 元素选择器，必须在块或另一个元素内部使用
 * @param {string} $element - 元素的名称
 * @example
 *   @include b(button) {
 *     @include e(icon) {
 *       font-size: 14px;
 *     }
 *   }
 *   // CSS Output
 *   .vf-button__icon {
 *     font-size: 14px;
 *   }
 */
@mixin e($element) {
  &__#{$element} {
    @content;
  }
}

/**
 * M - Modifier
 * 创建一个 BEM 修饰符选择器，用于修饰块或元素
 * @param {string} $modifier - 修饰符的名称
 * @example
 *   @include b(button) {
 *     @include m(primary) {
 *       background-color: blue;
 *     }
 *   }
 *   // CSS Output
 *   .vf-button--primary {
 *     background-color: blue;
 *   }
 */
@mixin m($modifier) {
  &--#{$modifier} {
    @content;
  }
}

/**
 * State - 状态
 * 创建一个状态类选择器，对应 `is-` 前缀的类名
 * @param {string} $state - 状态的名称 (e.g., 'disabled', 'active')
 * @example
 *   @include b(button) {
 *     @include when(disabled) {
 *       opacity: 0.5;
 *     }
 *   }
 *   // CSS Output
 *   .vf-button.is-disabled {
 *     opacity: 0.5;
 *   }
 */
@mixin when($state) {
  &.#{config.$namespace}-is-#{$state} {
    @content;
  }
}

/**
 * WHEN with implicit context (状态化上下文)
 * 创建一个状态化的后代上下文，允许 e 和 m 等 mixin 在其中无缝使用，
 * 就像在块的顶层一样，自动处理复杂的后代选择器。
 *
 * 最佳实践:
 * 当复合组件的根元素（Block）的状态需要改变其内部多个子元素（Element）
 * 的样式时，请使用此 mixin。
 *
 * @param {string} $state - 状态的名称 (e.g., 'on', 'disabled')
 * @example
 *   @include b(toggle-switch) {
 *     @include e(knob) { background-color: grey; }
 *
 *     @include when-with-context(on) {
 *       @include e(knob) { background-color: blue; }
 *     }
 *   }
 *   // CSS Output
 *   .vf-toggle-switch__knob { background-color: grey; }
 *   .vf-toggle-switch.is-on .vf-toggle-switch__knob { background-color: blue; }
 */
@mixin when-with-context($state) {
  $block-selector: &;
  $stateful-selector: selector.append($block-selector, '.#{config.$namespace}-is-#{$state}');
  @at-root #{$stateful-selector} {
    #{$block-selector} {
      @content;
    }
  }
}

/**
 * MODIFIER with implicit context (修饰符上下文)
 * 创建一个基于修饰符的后代上下文，允许 e 和 m 等 mixin 在其中无缝使用。
 *
 * 最佳实践:
 * 当块的某个变体（Modifier）需要改变其内部子元素（Element）的样式时，
 * 请使用此 mixin。
 *
 * @param {string} $modifier - 修饰符的名称 (e.g., 'primary', 'text')
 * @example
 *   @include b(button) {
 *     @include e(icon) { fill: black; }
 *
 *     @include m-with-context(primary) {
 *       @include e(icon) { fill: white; }
 *     }
 *   }
 *   // CSS Output
 *   .vf-button__icon { fill: black; }
 *   .vf-button--primary .vf-button__icon { fill: white; }
 */
@mixin m-with-context($modifier) {
  $block-selector: &;
  @at-root #{&}--#{$modifier} {
    #{$block-selector} {
      @content;
    }
  }
}
